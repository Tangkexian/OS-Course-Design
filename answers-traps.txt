1. 哪些寄存器包含函数的参数？例如，在main调用printf时，哪个寄存器保存了13？

   -  RISC-V 汇编语言中，函数的参数通常存储在寄存器 `a0` 到 `a7` 中。在main调用printf时，a2寄存器保存了13

2. 在main的汇编代码中，函数f的调用在哪里？函数g的调用在哪里？（提示：编译器可能会内联函数。）

   - 编译器将这些函数内联，那么它们的代码将直接嵌入到 `main` 函数中，而不是通过调用指令来调用。所以无函数调用。

3. 函数printf的地址是多少？

   - 回答：0x628

   - ```
     30:	00000097          	auipc	ra,0x0
     34:	5f8080e7          	jalr	1528(ra) # 628 <printf>
     ```

   auipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值+8。因此jalr会跳转1528+48=1576=0x628处，观察汇编代码可知在0628x处。

4. 在main中的jalr跳转到printf之后，寄存器ra中的值是多少？

   - **0x38**

   - jalr作用是跳转到立即数+指定寄存器处并且把ra的值+8。
   - 所以答案为：0x30+8=0x38

5. 运行以下代码，输出是什么？输出结果取决于RISC-V是小端序的事实。如果RISC-V是大端序的，为了得到相同的输出，你需要将i设置为什么值？你需要将57616更改为不同的值吗？

   ```c
   unsigned int i = 0x00646c72;
   printf("H%x Wo%s", 57616, &i);
   ```

   - 输出：HE110 World
   - 因为riscv为小端存储，从&i开始字节分别为0x72，0x6c，0x64， 0x00.分别对应’r’,‘l’,‘d’，'0’的ascii码，0x00作为字符串结束标志。57616=0xE110
   - 如果risc-v是大端序，i需要设置为0x726c64，57616不需要变。

6. 运行printf(“x=%d y=%d”, 3);在y=后面输出什么？为什么会这样？

   - 在 printf 函数中未写明 y 之后%d 所对应的值，所以输出的答案不确定，取决于寄存器a2中存储的值。